const std = @import("std");

// internals
const checker = @import("../../../../utils/checkers.zig");

const ValidProject = struct {
    build_zig: bool,
    zon_build_zig: bool,
    bin_file: bool,

    fn is_valid(self: ValidProject) bool {
        return self.bin_file and self.build_zig and self.zon_build_zig;
    }
};

pub fn is_valid_project(alloc: std.mem.Allocator, dir: std.fs.Dir) !bool {
    // var walker = try dir.walk(alloc);
    // defer walker.deinit();

    var valid_p = ValidProject{
        .build_zig = false,
        .zon_build_zig = false,
        .bin_file = false,
    };

    const full_path_dir = try dir.realpathAlloc(alloc, ".");
    defer alloc.free(full_path_dir);

    const folder_name = std.fs.path.basename(full_path_dir);
    const sep: u8 = std.fs.path.sep;

    // files generated by 'zig init'
    const build_zig_file = try std.fmt.allocPrint(alloc, "{s}{c}{s}", .{ full_path_dir, sep, "build.zig" });
    defer alloc.free(build_zig_file);

    const zon_build_zig_file = try std.fmt.allocPrint(alloc, "{s}{c}{s}", .{ full_path_dir, sep, "build.zig.zon" });
    defer alloc.free(build_zig_file);

    const bin_file = try std.fmt.allocPrint(alloc, "{s}{c}zig-out{c}bin{c}{s}", .{ full_path_dir, sep, sep, sep, folder_name });
    defer alloc.free(bin_file);

    // checks
    if (file_exists(dir, build_zig_file)) {
        valid_p.build_zig = true;
    } else {
        return false;
    }

    if (file_exists(dir, zon_build_zig_file)) {
        valid_p.zon_build_zig = true;
    } else {
        return false;
    }

    if (file_exists(dir, bin_file)) {
        valid_p.bin_file = true;
    } else {
        return false;
    }

    // return if ok
    return valid_p.is_valid();
}

fn file_exists(dir: std.fs.Dir, file_path: []const u8) bool {
    dir.access(file_path, .{}) catch |err| {
        if (err == error.FileNotFound) return false;
        return false;
    };
    return true;
}
